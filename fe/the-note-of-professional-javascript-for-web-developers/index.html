<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>读JavaScript高级程序设计 | 化学小子的前端实验册</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="manifest" href="/fe/manifest.json">
    <meta name="description" content="化学小子的前端实验册，记录学习中遇到的各种坑">
    <meta name="theme-color" content="#3eaf7c">
    <link rel="preload" href="/fe/assets/css/0.styles.2d25daf9.css" as="style"><link rel="preload" href="/fe/assets/js/app.d7dafe9a.js" as="script"><link rel="preload" href="/fe/assets/js/2.11505e39.js" as="script"><link rel="preload" href="/fe/assets/js/8.ff512c9c.js" as="script"><link rel="prefetch" href="/fe/assets/js/10.30bda224.js"><link rel="prefetch" href="/fe/assets/js/11.3bde3ae5.js"><link rel="prefetch" href="/fe/assets/js/12.188fe2ef.js"><link rel="prefetch" href="/fe/assets/js/13.107f4d99.js"><link rel="prefetch" href="/fe/assets/js/14.80a3bf87.js"><link rel="prefetch" href="/fe/assets/js/15.5e4555bd.js"><link rel="prefetch" href="/fe/assets/js/16.b3e4683b.js"><link rel="prefetch" href="/fe/assets/js/17.071c6be3.js"><link rel="prefetch" href="/fe/assets/js/18.27fa6860.js"><link rel="prefetch" href="/fe/assets/js/19.3412c1de.js"><link rel="prefetch" href="/fe/assets/js/20.f71cdd35.js"><link rel="prefetch" href="/fe/assets/js/21.acdb0eea.js"><link rel="prefetch" href="/fe/assets/js/22.1705f624.js"><link rel="prefetch" href="/fe/assets/js/23.1123b156.js"><link rel="prefetch" href="/fe/assets/js/24.5b6c3a1c.js"><link rel="prefetch" href="/fe/assets/js/25.faa8d474.js"><link rel="prefetch" href="/fe/assets/js/26.ab961ef0.js"><link rel="prefetch" href="/fe/assets/js/27.856176de.js"><link rel="prefetch" href="/fe/assets/js/28.e244d69a.js"><link rel="prefetch" href="/fe/assets/js/29.93d05a8a.js"><link rel="prefetch" href="/fe/assets/js/3.df576d5f.js"><link rel="prefetch" href="/fe/assets/js/30.dd5bacfd.js"><link rel="prefetch" href="/fe/assets/js/31.c9fe58cc.js"><link rel="prefetch" href="/fe/assets/js/4.9bcf4db0.js"><link rel="prefetch" href="/fe/assets/js/5.912b70e7.js"><link rel="prefetch" href="/fe/assets/js/6.28535f8c.js"><link rel="prefetch" href="/fe/assets/js/7.6dcbfed5.js"><link rel="prefetch" href="/fe/assets/js/9.61644727.js">
    <link rel="stylesheet" href="/fe/assets/css/0.styles.2d25daf9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fe/" class="home-link router-link-active"><!----> <span class="site-name">化学小子的前端实验册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/front-end-data-collation-and-learning-records/" class="nav-link">
  前端资料整理及学习记录
</a></li><li class="dropdown-item"><!----> <a href="/fe/front-end-adventure-roadmap/" class="nav-link">
  前端探险路线图
</a></li><li class="dropdown-item"><!----> <a href="/fe/the-note-of-professional-javascript-for-web-developers/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  读JavaScript高级程序设计
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">CSS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/css-two-column-layout/" class="nav-link">
  CSS效果 | 两栏布局那些事
</a></li><li class="dropdown-item"><!----> <a href="/fe/css-three-column-layout/" class="nav-link">
  CSS效果 | 三栏布局那些事
</a></li><li class="dropdown-item"><!----> <a href="/fe/css-tab-bar/" class="nav-link">
  CSS效果 | Tab选项卡
</a></li><li class="dropdown-item"><!----> <a href="/fe/css-swiper-picture/" class="nav-link">
  CSS效果 | 轮播图
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/a-few-simple-arithmetic-problems/" class="nav-link">
  JS | 几道简单的数学题
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/vue-start-note/" class="nav-link">
  Vue | 入手笔记
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-insert-data-to-dom/" class="nav-link">
  Vue | 如何将数据插入到DOM中
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-insert-data-to-elm-attr/" class="nav-link">
  Vue | 如何将数据插入到元素属性中
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-two-cp-computed-methods-v-if-show/" class="nav-link">
  Vue | computed和methods与v-if和v-show的故事
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-v-on-and-methods/" class="nav-link">
  Vue | v-on和methods的羁绊
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-v-model-and-form/" class="nav-link">
  Vue | v-model和form的羁绊
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-com-base-operation/" class="nav-link">
  Vue | 组件化基本操作
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-com-communication/" class="nav-link">
  Vue | 组件通信
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-com-personal/" class="nav-link">
  Vue | 组件个性化
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-package-a-tabbar-component-from-zero/" class="nav-link">
  Vue | 封装一个tabbar组件
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/those-things-of-the-network-requests/" class="nav-link">
  网络请求那些事情
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-mock-data/" class="nav-link">
  如何模拟后端数据
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-axios/" class="nav-link">
  axios那些事
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-koa-todolist-ssr-spa-api/" class="nav-link">
  以todolist为例，看前后端渲染
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-cors-break-origin-from-remove-blog/" class="nav-link">
  从博客迁移看跨域那点事儿
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/node-koa-start-learn/" class="nav-link">
  Koa初体验
</a></li><li class="dropdown-item"><!----> <a href="/fe/node-hexo-template-cemcoe/" class="nav-link">
  如何搞一个专属的 Hexo 的主题
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/front-end-data-collation-and-learning-records/" class="nav-link">
  前端资料整理及学习记录
</a></li><li class="dropdown-item"><!----> <a href="/fe/front-end-adventure-roadmap/" class="nav-link">
  前端探险路线图
</a></li><li class="dropdown-item"><!----> <a href="/fe/the-note-of-professional-javascript-for-web-developers/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  读JavaScript高级程序设计
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">CSS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/css-two-column-layout/" class="nav-link">
  CSS效果 | 两栏布局那些事
</a></li><li class="dropdown-item"><!----> <a href="/fe/css-three-column-layout/" class="nav-link">
  CSS效果 | 三栏布局那些事
</a></li><li class="dropdown-item"><!----> <a href="/fe/css-tab-bar/" class="nav-link">
  CSS效果 | Tab选项卡
</a></li><li class="dropdown-item"><!----> <a href="/fe/css-swiper-picture/" class="nav-link">
  CSS效果 | 轮播图
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">JS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/a-few-simple-arithmetic-problems/" class="nav-link">
  JS | 几道简单的数学题
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/vue-start-note/" class="nav-link">
  Vue | 入手笔记
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-insert-data-to-dom/" class="nav-link">
  Vue | 如何将数据插入到DOM中
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-insert-data-to-elm-attr/" class="nav-link">
  Vue | 如何将数据插入到元素属性中
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-two-cp-computed-methods-v-if-show/" class="nav-link">
  Vue | computed和methods与v-if和v-show的故事
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-v-on-and-methods/" class="nav-link">
  Vue | v-on和methods的羁绊
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-v-model-and-form/" class="nav-link">
  Vue | v-model和form的羁绊
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-com-base-operation/" class="nav-link">
  Vue | 组件化基本操作
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-com-communication/" class="nav-link">
  Vue | 组件通信
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-com-personal/" class="nav-link">
  Vue | 组件个性化
</a></li><li class="dropdown-item"><!----> <a href="/fe/vue-package-a-tabbar-component-from-zero/" class="nav-link">
  Vue | 封装一个tabbar组件
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">网络</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/those-things-of-the-network-requests/" class="nav-link">
  网络请求那些事情
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-mock-data/" class="nav-link">
  如何模拟后端数据
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-axios/" class="nav-link">
  axios那些事
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-koa-todolist-ssr-spa-api/" class="nav-link">
  以todolist为例，看前后端渲染
</a></li><li class="dropdown-item"><!----> <a href="/fe/network-cors-break-origin-from-remove-blog/" class="nav-link">
  从博客迁移看跨域那点事儿
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fe/node-koa-start-learn/" class="nav-link">
  Koa初体验
</a></li><li class="dropdown-item"><!----> <a href="/fe/node-hexo-template-cemcoe/" class="nav-link">
  如何搞一个专属的 Hexo 的主题
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>读JavaScript高级程序设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#读javascript高级程序设计" class="sidebar-link">读JavaScript高级程序设计</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第一章-缘起" class="sidebar-link">第一章 缘起</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-远古的故事" class="sidebar-link">1. 远古的故事</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-javascript组成部分" class="sidebar-link">2. JavaScript组成部分</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-制定规范时参考标准" class="sidebar-link">3. 制定规范时参考标准</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第二章-在-html中使用-javascript" class="sidebar-link">第二章 在 HTML中使用 JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-script-标签属性的变化" class="sidebar-link">1. script 标签属性的变化</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-运行流程预编译" class="sidebar-link">2. 运行流程预编译</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-标签放哪里" class="sidebar-link">3. 标签放哪里</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第二章番外-何为解释？" class="sidebar-link">第二章番外 何为解释？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-解释解释" class="sidebar-link">1. 解释解释</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-这玩意怎么解释" class="sidebar-link">2. 这玩意怎么解释</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-预编译过程" class="sidebar-link">3. 预编译过程</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-看一个例子" class="sidebar-link">4. 看一个例子</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_5-来预编译实战" class="sidebar-link">5. 来预编译实战</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_6-预编译四部曲" class="sidebar-link">6. 预编译四部曲</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_7-练习" class="sidebar-link">7. 练习</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第三章-基本概念" class="sidebar-link">第三章 基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-数据类型的变迁" class="sidebar-link">1. 数据类型的变迁</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-数据类型的检测" class="sidebar-link">2. 数据类型的检测</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-类型转换" class="sidebar-link">3. 类型转换</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-es2020-新增操作符" class="sidebar-link">4. ES2020 新增操作符</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_5-for-of-语句" class="sidebar-link">5. for of 语句</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第四章" class="sidebar-link">第四章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-值类型和引用类型的区别是什么？" class="sidebar-link">1. 值类型和引用类型的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-如何检测数据类型？" class="sidebar-link">2. 如何检测数据类型？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-作用域和作用域链是什么鬼？" class="sidebar-link">3.作用域和作用域链是什么鬼？</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第5章" class="sidebar-link">第5章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-引用类型和类和对象间是怎样的一种关系？" class="sidebar-link">1.引用类型和类和对象间是怎样的一种关系？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-ecmascript-预设了哪些原生的数据类型？" class="sidebar-link">2.ECMAScript 预设了哪些原生的数据类型？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-1-object" class="sidebar-link">2.1 Object</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-2-array" class="sidebar-link">2.2 Array</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-3-date" class="sidebar-link">2.3 Date</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-4-regexp" class="sidebar-link">3.4 RegExp</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-5-function" class="sidebar-link">3.5 Function</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-基本包装类" class="sidebar-link">3 基本包装类</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第六章" class="sidebar-link">第六章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-什么是面向对象？有哪些特点？" class="sidebar-link">1.什么是面向对象？有哪些特点？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-如何创建对象" class="sidebar-link">2.如何创建对象</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-1-工厂模式" class="sidebar-link">2.1 工厂模式</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-2-构造函数" class="sidebar-link">2.2 构造函数</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第六章番外" class="sidebar-link">第六章番外</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-构造函数原型实例三者是怎样的一个关系？" class="sidebar-link">1.构造函数原型实例三者是怎样的一个关系？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-如何确定一个属性是在对象本身还是在原型身上？" class="sidebar-link">2.如何确定一个属性是在对象本身还是在原型身上？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-原型方法创建对象的缺点？" class="sidebar-link">3.原型方法创建对象的缺点？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-较为合理的创建对象的方案是原型加构造函数？" class="sidebar-link">4.较为合理的创建对象的方案是原型加构造函数？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_5-es6中的class是怎么一回事" class="sidebar-link">5.ES6中的class是怎么一回事?</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第六章番外番外" class="sidebar-link">第六章番外番外</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-什么是原型链？如何使用原型链实现继承？" class="sidebar-link">1.什么是原型链？如何使用原型链实现继承？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-如何确定实例和原型的关系？" class="sidebar-link">2.如何确定实例和原型的关系？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-使用原型链实现继承有什么缺点？" class="sidebar-link">3.使用原型链实现继承有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-实现继承的可选方案有哪些？" class="sidebar-link">4.实现继承的可选方案有哪些？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_5-es6如何实现继承？" class="sidebar-link">5.ES6如何实现继承？</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第七章-函数表达式" class="sidebar-link">第七章 函数表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-函数的创建方式有哪些？" class="sidebar-link">1.函数的创建方式有哪些？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-函数有什么方法？" class="sidebar-link">2.函数有什么方法？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-函数运行" class="sidebar-link">3.函数运行</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-js运行三步曲" class="sidebar-link">4.js运行三步曲</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_5-预编译的过程-全文背诵" class="sidebar-link">5.预编译的过程(全文背诵)</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第七章-番外" class="sidebar-link">第七章 番外</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第八章" class="sidebar-link">第八章</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第十到十二章" class="sidebar-link">第十到十二章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-什么是dom" class="sidebar-link">1. 什么是DOM?</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-dom-是用来干什么的？" class="sidebar-link">2. DOM 是用来干什么的？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-如何选取dom元素？" class="sidebar-link">3.如何选取DOM元素？</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#h5" class="sidebar-link">H5</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-如何访问节点的属性？" class="sidebar-link">4. 如何访问节点的属性？</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第十三章" class="sidebar-link">第十三章</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-我点的是谁？" class="sidebar-link">1.我点的是谁？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_2-如何监测事件？" class="sidebar-link">2.如何监测事件？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_3-事件对象长啥样？" class="sidebar-link">3.事件对象长啥样？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_4-要监听的事件过多，处理不过来，怎么办？" class="sidebar-link">4.要监听的事件过多，处理不过来，怎么办？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_5-我可不可以自定义事件嘞？" class="sidebar-link">5.我可不可以自定义事件嘞？</a></li></ul></li><li><a href="/fe/the-note-of-professional-javascript-for-web-developers/#第二十章json" class="sidebar-link">第二十章JSON</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#_1-json的格式规范有哪些？" class="sidebar-link">1.JSON的格式规范有哪些？</a></li><li class="sidebar-sub-header"><a href="/fe/the-note-of-professional-javascript-for-web-developers/#解析和序列化" class="sidebar-link">解析和序列化</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="读javascript高级程序设计"><a href="#读javascript高级程序设计" class="header-anchor">#</a> 读JavaScript高级程序设计</h2> <h2 id="第一章-缘起"><a href="#第一章-缘起" class="header-anchor">#</a> 第一章 缘起</h2> <p>最近吧，总感觉自己的前端知识体系不是很系统。
自己像个咸鱼一般，对于一些原理不是很熟悉，有点拿来就用或现用现查的“毛病”。</p> <p>于是立一个flag，看一下这本很多人推荐的书。</p> <p>从书的目录来看呢，第三版有些东西在 2020 年可能已经无需再多关注。
比如关于 IE 兼容方面的内容。但不可否认，在知识体系结构方面是本好书。</p> <p>笔记会以 QA 的方式为主进行总结。</p> <p>主要参考 <a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener noreferrer">第三版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，第四版中文版预计 2020 下半年出，但那是 2019 年的计划，赶上今年这个事应该会推迟，从 <a href="https://www.ituring.com.cn/book/2472" target="_blank" rel="noopener noreferrer">图灵社区<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
来看，目前的状态是<code>正在排版</code>。<a href="https://www.amazon.com/Professional-JavaScript-Developers-Matt-Frisbie-ebook/dp/B07YP276S1/" target="_blank" rel="noopener noreferrer">英文版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 已经在亚马逊上架了。</p> <p>认认真真读一本书，哪怕是在知识爆炸的今天，看书还是很有必要的。</p> <p>我曾经妄图使用手机学东西，经过反反复复的循环过程，我放弃了。诱惑是在是太多或者说这些 APP 就是在故意勾引我，这些 APP 是真的狗。最终还是回到了读书这种方式。</p> <p>读书的时候呢，思想跟着作者，站在作者角度去思考，没准会有新的发现。</p> <blockquote><p>今天来看第一章，JavaScript简介。</p></blockquote> <p>很久很久以前，有一个城堡。。。</p> <h3 id="_1-远古的故事"><a href="#_1-远古的故事" class="header-anchor">#</a> 1. 远古的故事</h3> <p>很久以前上网就是为了获取信息，这里的信息更多的是文本，没有视频什么的。网站也没有什么用户体验的考量。能用就完事了。</p> <p>温饱思淫欲，，，</p> <p>据说当时在布局方式上使用表格布局，为了解决布局问题诞生了很多的 hack 手段，不要问我有什么 hack 手段，我还年轻。。。</p> <p>然而历史的车轮滚滚向前，人类却从未从历史中吸取过教训。</p> <p>那些年浏览器的兼容问题令人头疼，现在的各种小程序又何尝不是让人感到又有那味儿了呢？</p> <p>在苹果发布手机时，提了一个概念叫做用户体验，洋名是 User Experience，简称UE/UX，此时互联网公司也开始注意到网页与用户的交互问题。</p> <p>对了，几天前苹果在 iOS14 发布会上又搞出来一种 APP Clip，嗯，浏览器大战换成了小程序大战。</p> <p>据不完全统计，现在的平台有微信小程序，支付宝小程序，百度小程序，字节跳动小程序，QQ小程序，快应用，360小程序，PWA，APP Clip。</p> <p>以前前端开发要解决浏览器兼容问题，现在，嗯，10多种小程序环境还有部分的浏览器问题，加一块简直不要太他喵的酸爽。</p> <p>兼容性是前端一生之敌。抽空看一看uni-app，据说这货可以跨端开发。但总隐约觉得不靠谱。</p> <h3 id="_2-javascript组成部分"><a href="#_2-javascript组成部分" class="header-anchor">#</a> 2. JavaScript组成部分</h3> <p>通常所说的 JavaScript 其实包含三部分，ECMAScript | DOM | BOM。</p> <p>BOM 因为早期对窗口的滥用，浏览器做了很多的安全限制，现在相对于 DOM 使用的不是很多。</p> <p>而随着 MVVM 框架的出现，现在也很少直接操作 DOM。</p> <p>JavaScript拢共也就就三部分，现在其中的两个都因部分原因不被重视，所以我们学习的重点应该放在 ECMAScript 上，现在每年都会推出新的规范，现在最新的是 ECMAScript 2020，属于广义上的ES6。</p> <h3 id="_3-制定规范时参考标准"><a href="#_3-制定规范时参考标准" class="header-anchor">#</a> 3. 制定规范时参考标准</h3> <p>这些人在制定规范时参考的标准</p> <ul><li>将和浏览器相关的代码删除</li> <li>全面支持 Unicon 标准</li> <li>对象和平台无关</li></ul> <p>98 年标准发布到 2020，12年了。</p> <p>所以，重点应该放在对 ECMAScript 的使用上，这是重点重点重点。</p> <p>第一章更新于626。</p> <hr> <h2 id="第二章-在-html中使用-javascript"><a href="#第二章-在-html中使用-javascript" class="header-anchor">#</a> 第二章 在 HTML中使用 JavaScript</h2> <h3 id="_1-script-标签属性的变化"><a href="#_1-script-标签属性的变化" class="header-anchor">#</a> 1. script 标签属性的变化</h3> <p>首先是 script 标签的属性问题，在第三版中提到有 6 个属性，在第四版中已经变成了 8 个。</p> <div class="language-md extra-class"><pre class="language-md"><code>// 第三版
async charset defer language src type
// 第四版
async charset crossorigin defer intergrity language src type src type
</code></pre></div><p>可以看出多出来的两个属性是 crossorigin intergrity。</p> <p>然而并没什么，废话了这么多，实际上使用最多的就是一个 <code>src</code> 属性。</p> <h3 id="_2-运行流程预编译"><a href="#_2-运行流程预编译" class="header-anchor">#</a> 2. 运行流程预编译</h3> <p>在第三版 11 页中有那么一句话。</p> <blockquote><p>包含在 script 元素内部的 JavaScript 代码将被从上至下依次解释。</p></blockquote> <p>解释？何为解释？</p> <p>对于 JavaScript，预处理 + 执行 = 解释，这里展开会有很多内容，涉及变量提升，作用域等高阶知识，有空单独写。</p> <p>请看<a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%95%AA%E5%A4%96%E4%BD%95%E4%B8%BA%E8%A7%A3%E9%87%8A%EF%BC%9F">第二章番外何为解释？</a></p> <h3 id="_3-标签放哪里"><a href="#_3-标签放哪里" class="header-anchor">#</a> 3. 标签放哪里</h3> <p>js代码会阻断代码运行，通常会将 script 放到文档底部。</p> <p>那么有没有情况一定要放到前面？</p> <p>你别说，还真有，比如 Vue，<a href="https://github.com/vuejs/vuejs.org/blob/master/src/v2/examples/vue-20-hello-world/index.html" target="_blank" rel="noopener noreferrer">demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在这里，例子里 script 放到了 head 里面，这是因为后面要用到，如果将 script 放到文档的底部，那么在该 js 文件未加载前是无法使用 Vue 的。</p> <hr> <h2 id="第二章番外-何为解释？"><a href="#第二章番外-何为解释？" class="header-anchor">#</a> 第二章番外 何为解释？</h2> <p>对于 JavaScript，解释 = 预编译 + 执行，解释没那么简单，那么究竟什么是解释？</p> <h3 id="_1-解释解释"><a href="#_1-解释解释" class="header-anchor">#</a> 1. 解释解释</h3> <p>你来解释解释什么是解释？</p> <p>什么，TMD的是解释？
<img src="/fe/assets/img/2jiesi.0c09cc6d.jpg" alt="什么是解释"></p> <p>本来打算有空就写的，结果苟了几天，没有写了，感觉自己废了。</p> <p>主要是这个<code>解释</code>，难以解释。</p> <blockquote><p>黄四郎：好啊！三天之后，一定给县长一个惊喜！
张麻子：汤师爷，他是胡万的恩人，现在又成了你的恩人！你给翻译翻译，什么叫惊喜？翻译翻译，什么叫惊喜？
汤师爷：这还用翻译？都说了…
张麻子：我让你翻译给我听，什么叫惊喜！
黄四郎：不用翻译，就是惊喜啊！难道你听不懂什么叫惊喜？
张麻子：我就想让你翻译翻译，什么叫惊喜！
汤师爷：惊喜嘛……
张麻子：翻译出来给我听，什么他妈的叫惊喜！什么他妈的叫他妈的惊喜！
汤师爷：什么他妈的叫惊喜啊？
黄四郎：惊喜就是三天之后，我出一百八十万，给你们出城剿匪，接上我的腿！明白了吗？
汤师爷：这就是惊喜呀
张麻子：翻译翻译。翻译翻译！
汤师爷：惊喜就是三天之后，给你一百八十万两银子，出城剿匪，接上他的腿！
张麻子：大哥这个是惊喜啊！小弟我愿意等你三天。（拉过汤师爷来）黄老爷，汤师爷是我的至爱，你可不能夺我所爱啊！
黄四郎：了然，了然！</p></blockquote> <p>心态炸了，有没有？</p> <h3 id="_2-这玩意怎么解释"><a href="#_2-这玩意怎么解释" class="header-anchor">#</a> 2. 这玩意怎么解释</h3> <p>解释 = 预处理 + 执行，解释这个东西要怎么解释？</p> <p>书上没有呀，这时可以拿起另一本书 <a href="https://book.douban.com/subject/26351021/" target="_blank" rel="noopener noreferrer">你不知道的JavaScript（上卷）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来看一看。</p> <h3 id="_3-预编译过程"><a href="#_3-预编译过程" class="header-anchor">#</a> 3. 预编译过程</h3> <p>来看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">123</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
<span class="token comment">/**
 * a undefined
 * ---
 * b 123
 * Uncaught ReferenceError: c is not defined at index.js:11
*/</span>
</code></pre></div><p>我们知道在 ES6 中可以使用 const 和 let 定义变量，将上边的 var 换成 const 会出现什么的情况？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">123</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">123</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'---'</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
<span class="token comment">/**
 * Uncaught ReferenceError: Cannot access 'a' before initialization at index.js:1
*/</span>
</code></pre></div><p>直接报错，这是因为 ES6 中的 const 和 let 会形成暂时性死区，这就是另外一个故事了。</p> <p>回到 var 上面来，令人迷惑的是下面的代码片段：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">123</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>
</code></pre></div><p>如上面的代码所示，a 和 c 都是在没有被声明时调用了，但 a 得到的是 undefined，而 c 却报错了。</p> <p>两者的区别在于 a 最后补上了声明，而 c 始终没有声明。a 给人的感觉就是我先用，声明先欠着，等到某天我会还上的。而 c 完全就没有想要补上声明的意思。</p> <h3 id="_4-看一个例子"><a href="#_4-看一个例子" class="header-anchor">#</a> 4. 看一个例子</h3> <p>再来看一个例子，控制台会输出什么？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg4</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">234</span>
  <span class="token keyword">var</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>
<span class="token comment">/**
 * ƒ a(a) {
 * var a = 234
 * var a = function() {}
 * a()
 * }
* /
</span></code></pre></div><p>有一种刚学会 1+1 就要去做微积分的感觉。</p> <h3 id="_5-来预编译实战"><a href="#_5-来预编译实战" class="header-anchor">#</a> 5. 来预编译实战</h3> <p>再来一题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg5</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// f a() {}</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 123</span>
  <span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 123</span>
  <span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// f () {}</span>
  <span class="token keyword">function</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>口说无凭，打个断点调试一下。
<img src="/fe/assets/img/2debug1.12e81a64.gif" alt="打个断点"></p> <p>真刺激。</p> <p>预编译发生在函数执行的前一刻。</p> <h3 id="_6-预编译四部曲"><a href="#_6-预编译四部曲" class="header-anchor">#</a> 6. 预编译四部曲</h3> <ol><li>创建 AO 对象 Activation Object 执行期上下文</li> <li>找形参和变量声明，将变量和形参的名挂上，并赋值undefined</li> <li>将形参和实参相统一</li> <li>找函数声明，赋值函数体</li></ol> <p>下面是例子 eg5 产生 AO 的过程：</p> <div class="language-md extra-class"><pre class="language-md"><code>1.
AO {

}

2.
AO {
  a: undefined,
  b: undefined,
}

3.
AO {
  a: 1,
  b: undefined
}

4.
AO {
  a: function a() {},
  b: undefined,
  d: function d() {}
}
</code></pre></div><p>在代码执行时上哪里找a？就是上面的 AO，接下来按顺序就好了。预编译调和各个变量的冲突。在运行过程中，AO 也会动态变化。</p> <hr> <p>走一遍流程：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg6</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  c <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">var</span> c 
  a <span class="token operator">=</span> <span class="token number">3</span>
  b <span class="token operator">=</span> <span class="token number">2</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">b</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">d</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-md extra-class"><pre class="language-md"><code>// 走流程
<span class="token list punctuation">1.</span> 创建AO对象
AO {

}
<span class="token list punctuation">2.</span> 找形参和和变量声明并赋值undefined
AO {
  a: undefined
  b: undefined
  c: undefined
}
<span class="token list punctuation">3.</span> 人剑合一，将形参和实参相统一
AO {
  a: 1,
  b: undefined
  c: undefined
}
<span class="token list punctuation">4.</span> 找函数体声明赋值函数体，会覆盖第三步
AO {
  a: 1
  b: function b() {}
  c: undefined
  d: function d() {}
}
</code></pre></div><p>拿着我们的 AO 去和函数对线，打印顺序是122.</p> <p>我们来提炼一下，在预处理时，赋值函数体在形参和实参统一的后边，变量的赋值是在函数执行时发生的。</p> <h3 id="_7-练习"><a href="#_7-练习" class="header-anchor">#</a> 7. 练习</h3> <p>ok，来道题练一练，下面的console都会打印什么东西？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg7</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">234</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  a <span class="token operator">=</span> <span class="token number">123</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">var</span> a 
  b <span class="token operator">=</span> <span class="token number">234</span>
  <span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>不墨迹，直接写AO对象。</p> <div class="language-md extra-class"><pre class="language-md"><code>AO {
  a: function a() {}
  b: undefined
}
</code></pre></div><p>很简单，接下来拿着 AO 按照顺序执行就好了。</p> <p>对于全局而言全局生成GO Global Object，再来个复杂的题目。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// eg8</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">test</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
  <span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token number">234</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token number">123</span>
</code></pre></div><p>直接 AO GO 写起来。</p> <div class="language-md extra-class"><pre class="language-md"><code>GO {
  test: test(test){}
}

AO {
  test: test() {}
}
</code></pre></div><p>简单。，，这就是解释还没完，有空再写。</p> <p>本章更新于626。</p> <hr> <h2 id="第三章-基本概念"><a href="#第三章-基本概念" class="header-anchor">#</a> 第三章 基本概念</h2> <blockquote><p>这是第三章基本概念，这一章涉及变量，操作符，语句和函数等相关内容。是各种编程语言都有的部分。</p></blockquote> <p>主要的知识点：</p> <ul><li>ECMAScript 中究竟有几种数据类型？</li> <li>如何检测一个数据的数据类型？</li> <li>为什么 typeof null 的结果会是 object？</li> <li>数据类型间的互相转化如何进行？</li> <li><a href="https://www.jianshu.com/p/d6586d4c33f9" target="_blank" rel="noopener noreferrer">ES2020<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>新增操作符使用场景？</li> <li>for of 语句使用场景？</li></ul> <h3 id="_1-数据类型的变迁"><a href="#_1-数据类型的变迁" class="header-anchor">#</a> 1. 数据类型的变迁</h3> <p>根据网上的资料可以知道 ECMAScript 的数据类型存在三次变迁。</p> <p>刚开始的 6 种数据类型：Null Undefined Boolean Number String Object</p> <p>ES6 来了之后添加了一个新成员：Symbol</p> <p>ES2020 来了之后添加了另一个新成员：BigInt</p> <p>所以说站在 ES2020 的角度来看，ECMAScript 有 8 种数据类型。</p> <p>高程这本书第三版是最开始的 6 种的情况，第四版提到了Symbol。</p> <p>同时还有另一种分类方法，Object还被称为complex data type，其他7种数据类型还称primitive types。</p> <p><img src="/fe/assets/img/3datatypechange.c7a91991.png" alt="数据结构的变迁"></p> <p>来看一下两个新朋友，Symbol 和 BingInt。</p> <p>Symbol 在 js 中代表独一无二的值，目前能想到的应用场景是，利用 Symbol 值作为属性名可以很好的避免复杂对象中含有多个属性的时容易将某个属性名覆盖掉的情况。</p> <p>BingInt其实也算是<a href="https://www.jianshu.com/p/d8b8ed62384f" target="_blank" rel="noopener noreferrer">老朋友<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>了。</p> <p>好的，我们现在已经知道了 ESMAScript 中有Null Undefined Boolean Number String Object Symbol BigInt 8 种数据类型，接下来的问题是当我们拿到一个数据，比如通过 ajax 向后端请求到数据后，如何检测该数据的数据类型？</p> <h3 id="_2-数据类型的检测"><a href="#_2-数据类型的检测" class="header-anchor">#</a> 2. 数据类型的检测</h3> <p>为什么要对数据的类型进行检测？想必大家在高考时都见过类似的题目：
<img src="/fe/assets/img/3question1.ea0947df.png" alt=""></p> <p>做事情前要验明正身，是谁，是敌人还是朋友，对人体有害吗？</p> <p>这里对数据进行检测是因为每种数据类型有不同的特性或者说是结构，有不同的处理方案。</p> <p>在搞事情前的第一步要搞清楚这个数据是个啥玩意儿？化学种可以使用各种试剂比如银氨溶液等来检测。</p> <p>而在这里对于数据类型的检测可以使用几个方案。</p> <p>typeof instnceof
每种检测方法各有优缺点，下面依次测试。
首先的typeof ，需要注意两点，typeof 是操作符，使用时可以不加括号，其次使用typeof检测的结果本身的数据结构是字符串，即</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> 管你是你哈<span class="token punctuation">)</span> <span class="token operator">===</span>  <span class="token string">'string'</span>
</code></pre></div><p><img src="/fe/assets/img/3typeof.6f07114d.png" alt="typeof"></p> <p>从图中可以看出 typeof 的结果和数据类型并不是严格意义上的一一对应，和我们料想的不一样的点在于 Object 和 Null。</p> <p>这里就有一些问题了，为什么 typeof null 的结果会是 object？</p> <p>在MDN上找到的解释是：</p> <blockquote><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null 的类型标签是 0，typeof null 也因此返回 &quot;object&quot;。</p></blockquote> <p><a href="https://2ality.com/2013/10/typeof-null.html" target="_blank" rel="noopener noreferrer">https://2ality.com/2013/10/typeof-null.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>综上，如果你要判断变量是 Undefined Boolean 等简单数据类型，那么 typeof 可以使用，但如果你要检测一个变量是否为对象，或者具体的对象类型，那么，typeof 可能无能为力。</p> <p>还有instanceof方法检测，后面再说。</p> <p>如何检测空数组？如何检测空对象？</p> <h3 id="_3-类型转换"><a href="#_3-类型转换" class="header-anchor">#</a> 3. 类型转换</h3> <p>就像水可以在自然界中通过一定的条件在气态，液态和固态间不断转化一样，数据的类型也可以通过一些方式进行转变。</p> <p>这里的转换方式分为两种，分别是隐式类型转换和显式类型转换。</p> <p>但总结。。。</p> <h3 id="_4-es2020-新增操作符"><a href="#_4-es2020-新增操作符" class="header-anchor">#</a> 4. ES2020 新增操作符</h3> <div class="language-md extra-class"><pre class="language-md"><code>?? 空值合并运算符
?. 可选链操作符
</code></pre></div><p>这两个操作符都和 Null 和 Undefined 相关。</p> <p>空值合并运算符：当左侧操作数为 null 或 undefined 时，其返回右侧的操作数。否则返回左侧的操作数。在这里就要提到 || 了，逻辑或会在左操作数为假值时返回右侧操作数。两者的区别在于返回右侧操作数的条件。</p> <p>可选链：当不能保证哪些属性是必需的时，?.操作符对于探索一个对象的内容是很有帮助的。</p> <p>如何要找一个对象的属性值，一般会先 hasOwnProperty() 检查一下是否有该属性名，确认后会使用点操作符或者中括号取到属性值，有点麻烦。</p> <p>有了可选链：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> age <span class="token operator">=</span> obj<span class="token punctuation">.</span>cemcoe<span class="token operator">?.</span>age<span class="token punctuation">;</span>
<span class="token comment">// 当obj里存在cemcoe时，去拿age值</span>
<span class="token comment">// 不存在时返回undefined</span>
</code></pre></div><h3 id="_5-for-of-语句"><a href="#_5-for-of-语句" class="header-anchor">#</a> 5. for of 语句</h3> <p>先来一段很熟悉的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>上面是经常用到的操作，对数据进行遍历，但有时我们可能并不需要索引，即上文中的i，我们只想要对item进行相关的操作，这时上面的方法就有点笨重了，那么如何解决呢？</p> <p>可以使用 for of。</p> <p>本章更新于626</p> <hr> <h2 id="第四章"><a href="#第四章" class="header-anchor">#</a> 第四章</h2> <blockquote><p>这是第四章基本概念，这一章涉及变量、作用域和内存问题等相关内容。
主要知识点：</p></blockquote> <ul><li><ol><li>值类型和引用类型的区别是什么？</li></ol></li> <li><ol start="2"><li>如何检测数据类型？</li></ol></li> <li><ol start="3"><li>作用域和作用域链是什么鬼？</li></ol></li></ul> <hr> <h3 id="_1-值类型和引用类型的区别是什么？"><a href="#_1-值类型和引用类型的区别是什么？" class="header-anchor">#</a> 1. 值类型和引用类型的区别是什么？</h3> <p>第三章讲到ESMAScript2020中有8种数据结构，其实还有一种分法两种就足够了。</p> <p>这种分类的依据是操作时是自身还是数据的代理人，分为值类型和引用类型。</p> <p>在 <a href="https://www.jianshu.com/p/7abebcc75978" target="_blank" rel="noopener noreferrer">02-1 | 读JavaScript 高程 | 解释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中提到，JavaScript 的解释分为预编译和执行，而在执行的变量赋值阶段解析器需要判断变量是值类型还是引用类型。</p> <p>为什么要多一道判断呢？</p> <p>这是因为两种的操作方式不同，引用类型是保存在内存中的，无法直接操作就像一个代理人一样。</p> <p>值类型就像是小企业的老板，想找他直接找本人就好。引用类型就像是大公司的老总，有事也不能直接冲到办公室，一般是由秘书负责代理操作。</p> <p>定义时值类型和引用类型没差别，在使用的时候就不同了，你可以给引用类型添加属性和删除属性，对于引用类型是一件很简单的事情，毕竟是大公司的老总。但对于值类型，小老板没有闲钱去开展新业务，硬要添加属性会得到 undefined 的结果。</p> <p>两者的另一个区别出现在赋值操作过程中，对于值类型，直接再复制一份，对于值类型，复制不过是添加了一个指针。有一个例子可以很好的理解这个东西，用过网盘的都知道，但别人分享给我们文件时，发来的是一个链接，那么此时约等于我们复制了别人的文件，这时的复制就是引用类型的复制，我们有权限访问文件，但这份文件是两者公用的，一人对该文件的操作会影响到所有人。一般得到别人的分享链接后，我们一般会执行一个操作，那就是保存到我的网盘。这种操作就是值类型的复制，每份复制的文件各自独立互不影响。</p> <h3 id="_2-如何检测数据类型？"><a href="#_2-如何检测数据类型？" class="header-anchor">#</a> 2. 如何检测数据类型？</h3> <p>这是一个涉及面蛮广的话题，有空写。</p> <h3 id="_3-作用域和作用域链是什么鬼？"><a href="#_3-作用域和作用域链是什么鬼？" class="header-anchor">#</a> 3.作用域和作用域链是什么鬼？</h3> <p>也是一个满重要的点，这一章就是简单的介绍，后面写。</p> <p>第四章，完。</p> <hr> <h2 id="第5章"><a href="#第5章" class="header-anchor">#</a> 第5章</h2> <blockquote><p>这是第五章引用类型，这一章涉及引用类型的种类，各个类型身上的方法等相关内容。</p></blockquote> <p>主要知识点：</p> <ul><li>1.引用类型和类和对象间是怎样的一种关系？</li> <li>2.ECMAScript 预设了哪些原生的数据类型？</li> <li>3.作为值类型的string为什么可以调用方法？</li> <li>4.包装类是个什么东西？</li></ul> <h3 id="_1-引用类型和类和对象间是怎样的一种关系？"><a href="#_1-引用类型和类和对象间是怎样的一种关系？" class="header-anchor">#</a> 1.引用类型和类和对象间是怎样的一种关系？</h3> <p>ECMAScript 中的引用类型是一种数据结构，可以将数据和功能结合在一起，有时也被称为类。但在ECMAScript 中始终都没有类，哪怕到了 ES6 中的 class，依然只是一个语法糖。而对象则是引用类型的一个实例，一个引用类型可以创造好多好多的对象。</p> <p>对象都具有三个方法：</p> <ul><li>toLocaleString()</li> <li>toString() 当需要输出字符串时会隐式调用该方法</li> <li>valueOf()</li></ul> <h3 id="_2-ecmascript-预设了哪些原生的数据类型？"><a href="#_2-ecmascript-预设了哪些原生的数据类型？" class="header-anchor">#</a> 2.ECMAScript 预设了哪些原生的数据类型？</h3> <p>记得吗？H5 中对一些标签做了初始化 CSS 设置，用起来方便不少，你想用一种标签来写整个网页理论上也是可以的，不过是麻烦了一些。</p> <p>同样的，为了方便大家的操作，ESMAScript 定义了一些常用的原生引用类型，我们可以用这些东西方便快捷地创造我们想要的对象。</p> <p>主要有以下几种：</p> <ul><li>Object</li> <li>Array</li> <li>Date</li> <li>RegExp</li> <li>Function</li></ul> <h3 id="_2-1-object"><a href="#_2-1-object" class="header-anchor">#</a> 2.1 Object</h3> <p>Object 是一个比较单纯的引用类型，功能不多，但因其单纯，但我们想要造一个自己的对象时，用 Object 最好不过了。</p> <h3 id="_2-2-array"><a href="#_2-2-array" class="header-anchor">#</a> 2.2 Array</h3> <p>Array 时 ECMAScript 中非常重要的数据类型，问题涉及如何检测数据，常用方法，各种算法，ES6 扩展等。当数组调用 toString() 方法时，会返回由数组中的额每个值的字符串形式拼接成的以逗号分隔的字符串。效果与 arr.join(',') 相同。
数组中的方法可以分为以下几种：</p> <ul><li>转换方法 toLocaleString() toString() valueOf()</li> <li>栈方法 push() pop()</li> <li>队列方法 shift() push()</li> <li>重排序方法 reverse() sort()</li> <li>操作方法 concat() slice() splice()</li> <li>位置方法 indexOf() lastIndexOf()</li> <li>迭代方法 every() some() forEach() map() filter()</li> <li>归并方法 reduce()
因数组相关的问题涉及太多，有空单拎出来写。</li></ul> <h3 id="_2-3-date"><a href="#_2-3-date" class="header-anchor">#</a> 2.3 Date</h3> <p>Date 这个类型也是蛮有意思的，还记得 <a href="https://www.jianshu.com/p/d8b8ed62384f" target="_blank" rel="noopener noreferrer">0.1+0.2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的问题吗？这里也有一个不符合我们预期的问题。</p> <p>ECMAScript 中的 Date 抄的 Java.util.Date ，但这里是有不当的地方的，但就硬抄了过来。比如 getMonth() ，按照语义化来讲，应该返回月份，但你试了以后会发现返回的是 月份-1 ，你要说它就是规定从 0 开始吧，但 getDate() 返回的则就是实在的 日期，没有 -1，这就让人很困惑，就这两个方法举例。至于其它的方法，现用现查就好。这个故事告诉我们，抄作业看着点，别硬着头皮抄，但这些不合理的地方用的人多了也就不好改了。错别字慢慢变成通假字。</p> <h3 id="_3-4-regexp"><a href="#_3-4-regexp" class="header-anchor">#</a> 3.4 RegExp</h3> <p>这是一个功能强大的类型，现在还不是很会，略过。什么时候想玩爬虫，再好好学一学。</p> <h3 id="_3-5-function"><a href="#_3-5-function" class="header-anchor">#</a> 3.5 Function</h3> <p>函数是一等公民，还满特殊的，使用typeof检测时，其他引用类型得到 &quot;object&quot;，函数得到 &quot;function&quot;，搞特殊。</p> <p>定义函数有两种方式：函数声明和函数表达式，这两种方式会在 <a href="https://www.jianshu.com/p/7abebcc75978" target="_blank" rel="noopener noreferrer">预编译<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 时体现出不同。</p> <p>后面的章节会有更详细的说明。</p> <h3 id="_3-基本包装类"><a href="#_3-基本包装类" class="header-anchor">#</a> 3 基本包装类</h3> <ul><li>Boolean</li> <li>Number</li> <li>String</li></ul> <p>string可以有方法吗？按理来讲，值类型是没有方法可以调用的，但你尝试以下就会发现，是可以的，比如 str.substring(2)。</p> <p>真神奇。那么 ECMAScript 帮我们做了什么呢？</p> <p>它帮我们创建了基本包装类的一个实例，并在在实例上调用方法，随后销毁了该实例。</p> <hr> <h2 id="第六章"><a href="#第六章" class="header-anchor">#</a> 第六章</h2> <blockquote><p>这是第六章面向对象的程序设计，这一章涉及到一些概念和思想，也是 JavaScript 中很重要的知识点。需要注意的是在第四版中，这部分内容在第八章，在第四版中增加的内容是 Collection Reference Types 和 Iterators and Generatiors。这里还是以第三版为参考。</p></blockquote> <p>知识点：</p> <ul><li>1.什么是面向对象？有哪些特点？</li> <li>2.如何创建对象？创建对象的方法进化过程？</li> <li>3.创造出的对象如何自我进化，像人类社会一样不断发展？</li></ul> <h3 id="_1-什么是面向对象？有哪些特点？"><a href="#_1-什么是面向对象？有哪些特点？" class="header-anchor">#</a> 1.什么是面向对象？有哪些特点？</h3> <p>首先，这个东西的洋名是 Object Oriented，上一章提到，对象是由引用类型 new 出来的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> avstar <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;三上悠亚&quot;</span><span class="token punctuation">,</span>
  jpName<span class="token operator">:</span> <span class="token string">&quot;きとう ももな&quot;</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;singer&quot;</span><span class="token punctuation">,</span>
  <span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'yep'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上，创建了一个名为 <code>きとうももな</code> 的 av 对象，该对象有三个属性分别是 name jpName job，同时，该对象还有一个 sing 的技能，术语叫方法。</p> <p>在这些属性身上定义了一些特征，这些特征限制了属性的一些权限，分为数据属性和访问器属性。</p> <p>数据属性有默认值，修改使用 <code>Object.defineProperty()</code>。</p> <ul><li>[[Configurable]]</li> <li>[[Enumerable]]</li> <li>[[Writable]]</li> <li>[[Value]]</li></ul> <p>访问器属性和数据属性相似，但没有 Value ，它们可以包含非必须的 getter 和 setter 函数。在读取时调用 getter 函数，设置时调用 setter 函数，想到了 Vue 中的计算属性为什么写的是函数而用的时候是按照属性的方式使用的。</p> <ul><li>[[Configurable]]</li> <li>[[Enumerable]]</li> <li>[[Get]]</li> <li>[[Set]]</li></ul> <p>在这里记忆一下代码规范，像以下划线开头的变量 _year 用于表示只能通过对象方法访问的属性。</p> <p>前面是对属性特性的简单介绍，下面来看如何查看？
可以使用 <code>Object.getOwnPropertyDescriptor()</code>。</p> <hr> <h3 id="_2-如何创建对象"><a href="#_2-如何创建对象" class="header-anchor">#</a> 2.如何创建对象</h3> <ul><li>工厂模式</li> <li>构造函数</li> <li>原型</li> <li>组合使用构造函数和原型</li> <li>动态原型</li> <li>寄生构造函数</li> <li>稳妥构造函数</li> <li>ES6 class</li></ul> <p>创建对象还不简单？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;cemcoe&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">18</span>&quot;
<span class="token punctuation">}</span>
</code></pre></div><p>但这种方式用来创建单个对象还好，但如果要创建多个对象可能会变成这个样子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;cemcoe&quot;</span><span class="token punctuation">,</span>
age<span class="token operator">:</span> <span class="token number">18</span>&quot;
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;cemcoe111&quot;</span><span class="token punctuation">,</span>
age<span class="token operator">:</span> <span class="token number">18</span>&quot;
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person3 <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;cemcoe222&quot;</span><span class="token punctuation">,</span>
age<span class="token operator">:</span> <span class="token number">18</span>&quot;
<span class="token punctuation">}</span>
</code></pre></div><p>发现没有，代码有重复的地方，这才3个，如果要搞100个对象，那也太不优雅了。</p> <h3 id="_2-1-工厂模式"><a href="#_2-1-工厂模式" class="header-anchor">#</a> 2.1 工厂模式</h3> <p>就像现代的工业化流程一样，有一种解决方法叫做工厂模式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  o<span class="token punctuation">.</span>name <span class="token operator">=</span> name
  o<span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token keyword">return</span> o
<span class="token punctuation">}</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;cemcoe&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;cemcoe111&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> person3 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;cemcoe222&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
</code></pre></div><p>和前面相比重复代码变少了，虽然可以创建多个相似的对象，但是无法知道对象的类型，这种模式有缺陷。</p> <h3 id="_2-2-构造函数"><a href="#_2-2-构造函数" class="header-anchor">#</a> 2.2 构造函数</h3> <p>下面是构造函数的模式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;cemcoe&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;cemcoe111&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> person3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;cemcoe222&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
</code></pre></div><p>和工厂模式相比，构造函数模式没有显式地创建对象，省去了 return 语句。
这里又有一个代码规范，构造函数使用大写字母开头以便和普通函数区分。</p> <p>重点！！！</p> <p>看起来少了很多东西，但这个 new 操作符究竟做了什么？</p> <ul><li>创建一个新对象</li> <li>将构造函数的作用域给到新对象，this指向新对象</li> <li>执行构造函数的代码，为对象添加属性</li> <li>返回新对象</li></ul> <p>person person1 person2 分别保存 Person 的一个不同的实例。这些对象都有一个 constructor 属性，该属性指向 Person，这里就解决了工厂模式无法确定对象类型的问题。</p> <p>当然，如何要检测对象类型时使用 instanceof 靠谱一些。
person instanceof Person 意思是 person 是 Person 的 instance 吗？</p> <p>构造函数和普通函数的区别是两种的调用方式不同。</p> <p>那么构造函数有什么问题内？</p> <p>问题在于如果在构造函数中为对象的方法时，每次new一个实例方法也会创建方法实例。</p> <hr> <p>这时就轮到原型出场了。
构造函数的问题是，对象中的方法没有办法复用。
下篇接着看。。。
接上篇</p> <h2 id="第六章番外"><a href="#第六章番外" class="header-anchor">#</a> 第六章番外</h2> <p>知识点：
1.构造函数原型实例三者是怎样的一个关系？
2.如何确定一个属性是在对象本身还是在原型身上？
3.原型方法创建对象的缺点？
4.较为合理的创建对象的方案是原型加构造函数？
5.ES6中的class是怎么一回事?</p> <h3 id="_1-构造函数原型实例三者是怎样的一个关系？"><a href="#_1-构造函数原型实例三者是怎样的一个关系？" class="header-anchor">#</a> 1.构造函数原型实例三者是怎样的一个关系？</h3> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-35ade50f6aecd13d.jpg" alt=""></p> <p>每个函数都有一个属性叫做 prototype 指向该函数的原型对象，而该原型对象也有一个属性叫做 constructor 指回了函数，两者形成了一个圈。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-50b61d724776bca7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>在采用原型创造对象时涉及三个东西，构造函数，原型对象，实例即要创建的对象。问题的关键是搞明白这三者的关系。</p> <p>前面是函数和原型对象的关系，函数通过ptototype 指向原型对象，原型对象通过constructor指向函数，这就是两者的关系。</p> <p>下面我们将实例添加进来。</p> <p>首先是构造函数和实例的关系，实例通过构造函数创建，实例有一个属性[[prototype]] 指向构造函数的原型对象，但实例和构造函数间并无此项直接的联系。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-b54d601a9dd4034f.jpg" alt=""></p> <p>三者的关系是这样的：彼此间通过指针连接，函数和原型是互相指的关系，实例和原型是单向指向的关系，函数和实例间没有直接的指向关系。</p> <h3 id="_2-如何确定一个属性是在对象本身还是在原型身上？"><a href="#_2-如何确定一个属性是在对象本身还是在原型身上？" class="header-anchor">#</a> 2.如何确定一个属性是在对象本身还是在原型身上？</h3> <p>先来看两个 API，hasOwnPrototype() 方法 和 in 操作符。</p> <p>hasOwnPrototype() 方法只在属性存在实例本身时返回 true，当属性只存在在原型上时返回false。而 in 操作符，不管属性定义在哪里，只要有就返回 true。两者配合就可以确定属性定义的位置。</p> <p>比如 in 操作符为 false 时，属性在原型和实例本身都不存在，这是就不需要 hasOwnPrototype() 出马了。而当 in 操作符为 true 且 hasOwnPrototype() 方法为 false  时，该属性存在于原型中。</p> <h3 id="_3-原型方法创建对象的缺点？"><a href="#_3-原型方法创建对象的缺点？" class="header-anchor">#</a> 3.原型方法创建对象的缺点？</h3> <p>对于属性中的引用类型一处更改全部都会变动，每处都会受到影响。</p> <h3 id="_4-较为合理的创建对象的方案是原型加构造函数？"><a href="#_4-较为合理的创建对象的方案是原型加构造函数？" class="header-anchor">#</a> 4.较为合理的创建对象的方案是原型加构造函数？</h3> <p>构造函数和原型可以互相补充，实例属性的定义交给构造函数，而实例通用的属性和方法交给原型定义。这样就可以求同存异，节约内存资源。</p> <p>书中来提到了动态原型模式，寄生构造函数模式以及稳妥构造函数模式，有兴趣的可以看一下。</p> <p>构造函数和原型模式结合的方式对于大部分场景已经可以解决了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 构造函数</span>
<span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token comment">// 原型</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person
  <span class="token comment">// 防止指向乱掉</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 创建实例对象</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'cemcoe'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
<span class="token comment">// p1对象相当于</span>
<span class="token comment">// p1 = {</span>
<span class="token comment">//   name: 'cemcoe',</span>
<span class="token comment">//   age: 10,</span>
<span class="token comment">//   sayName() {</span>
<span class="token comment">//     console.log('cemcoe')</span>
<span class="token comment">//   }</span>
<span class="token comment">// }</span>
</code></pre></div><h3 id="_5-es6中的class是怎么一回事"><a href="#_5-es6中的class是怎么一回事" class="header-anchor">#</a> 5.ES6中的class是怎么一回事?</h3> <p>首先明确一点，class只是一个语法糖。</p> <p>将上面的代码使用 class 进行改写如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// 构造函数</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token punctuation">}</span>
  <span class="token comment">// 原型</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用时没有变化</span>
<span class="token comment">// 创建实例对象</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'cemcoe'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看到 ES6 的 class 用起来代码结构更加的清晰，对函数的定义被大括号包裹着，不会显得很乱。</p> <p>对创建对象方法的探索暂时告一段落，推荐使用 ES6 中的 class 来组织代码，下篇来看继承。</p> <hr> <h2 id="第六章番外番外"><a href="#第六章番外番外" class="header-anchor">#</a> 第六章番外番外</h2> <p>接上篇</p> <blockquote><p>经过一番的折腾，我们已经能够像女娲一样造人了，现在要做的就是如何让我们造出来的人能够进化，站在巨人的肩膀上不断地发展，术语叫做继承。</p></blockquote> <p>知识点：
1.什么是原型链？如何使用原型链实现继承？
2.如何确定实例和原型的关系？
3.使用原型链实现继承有什么缺点？
4.实现继承的可选方案有哪些？
5.ES6如何实现继承？</p> <p>继承的思路是使用原型让一个引用类型继承另一个引用类型的属性和方法。</p> <h3 id="_1-什么是原型链？如何使用原型链实现继承？"><a href="#_1-什么是原型链？如何使用原型链实现继承？" class="header-anchor">#</a> 1.什么是原型链？如何使用原型链实现继承？</h3> <p>前面提到过构造函数，原型和实例三者之间的关系。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-47c06a6d20746ff4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>现在假设原型等于另一个类型的实例，那么此时原型和实例的结合体会指向另一个原型，如果再假设此原型是另一组原型和实例的结合，那么该原型会指向另一个原型，这就是原型链。文字有点绕，画个图。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-feadf246534924b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>站在 A 实例的角度来看，有这么一个指向关系，A实例-&gt;A原型=B实例-&gt;B原型=C实例-&gt;C原型，这就是原型链的名字的意义。</p> <p>原型链形成的关键是一个原型和另一个实例的链接，正是这种链接将两种原型连到了一块。下面用代码来看一下原型链。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 先搞定A相关代码</span>
<span class="token comment">// A Function</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token comment">// A prototype</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>

<span class="token comment">// B Function</span>
<span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
<span class="token punctuation">}</span>
<span class="token comment">// B prototype</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getAge</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span>

<span class="token comment">// 继承的关键代码 A 继承 B  A 的原型指向了 B 实例，</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 现在 A 原型拥有了 B 实例中的属性和方法</span>
</code></pre></div><h3 id="_2-如何确定实例和原型的关系？"><a href="#_2-如何确定实例和原型的关系？" class="header-anchor">#</a> 2.如何确定实例和原型的关系？</h3> <p>本来呢，确定实例和原型的关系很简单，但现在有了原型链，作为一个链条结构，确定实例与原型的关系就需要一些方法了。</p> <p>有两个方法，一个是 instanceof 操作符，另一个是 isPrototypeOf() 方法。</p> <p>两种方法的例子如下：</p> <div class="language-md extra-class"><pre class="language-md"><code>// instanceof
实例 instanceof 原型链中的构造函数 = true
// instance 实例 什么是什么的实例吗？

// isPrototypeOf 什么是什么的原型吗？
原型.isPrototypeOf(实例)

// 注意两种方法中实例的位置，有一种把字句和被字句的感觉。
</code></pre></div><h3 id="_3-使用原型链实现继承有什么缺点？"><a href="#_3-使用原型链实现继承有什么缺点？" class="header-anchor">#</a> 3.使用原型链实现继承有什么缺点？</h3> <ul><li>引用类型值的原型属性会被所有实例共享</li> <li>没有办法在不影响所有对象实例的情况下给超类型的构造函数传递参数。</li></ul> <h3 id="_4-实现继承的可选方案有哪些？"><a href="#_4-实现继承的可选方案有哪些？" class="header-anchor">#</a> 4.实现继承的可选方案有哪些？</h3> <p>既然使用原型链进行继承有缺点，那么实现继承有哪些方案可选呢？</p> <p>书中提到了原型链，借用构造函数，组合继承，原型式继承，寄生式继承以及寄生组合式继承等方法。</p> <p>那么来看借用构造函数如何来实现继承。</p> <p>前面说到，原型链实现继承有两大缺点，对于其中的引用类型问题，借用构造函数可以解决。思路是在子类型构造函数内部调用超类型构造函数。</p> <p>这里要用到 call 和 apply，这两货到函数章节再说。但仅依靠构造函数，还是有些问题，方法在构造函数中定义，函数无法复用。</p> <p>那么我们可以将原型链和构造函数结合起来实现继承，这种方法被称为组合继承，思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p> <p>常用的实现继承的方法就是原型链和构造函数的组合了。</p> <h3 id="_5-es6如何实现继承？"><a href="#_5-es6如何实现继承？" class="header-anchor">#</a> 5.ES6如何实现继承？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token comment">// 构造函数</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
  <span class="token punctuation">}</span>
  <span class="token comment">// 原型</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用时没有变化</span>
<span class="token comment">// 创建实例对象</span>
<span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'cemcoe'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>

<span class="token comment">// 继承 cemcoe 继承 Person</span>
<span class="token keyword">class</span> <span class="token class-name">cemcoe</span> extend Person <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不得不说关于面向对象的内容是真多。</p> <h2 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="header-anchor">#</a> 第七章 函数表达式</h2> <blockquote><p>这是第七章函数表达式，这一章涉及函数预编译，闭包，作用域链内容。函数涉及内容繁多。</p></blockquote> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-847024b7c04a706f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>前情提要 <a href="https://www.jianshu.com/p/7abebcc75978" target="_blank" rel="noopener noreferrer">02-1 | 读JavaScript 高程 | 解释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这章的重点其实在函数预编译时发生事情。</p> <p>我们知道对象是属性和方法的合集。而我们的函数其实也是对象，所以对象上的一些东西，或者说原型链上的方法是可以使用的。</p> <p>通过实验来了解一些这波知识。</p> <p>那么问题来了，第一步如何逮到实验要用的小白鼠。
<img src="https://upload-images.jianshu.io/upload_images/3750332-f7c00c433d78124b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <h3 id="_1-函数的创建方式有哪些？"><a href="#_1-函数的创建方式有哪些？" class="header-anchor">#</a> 1.函数的创建方式有哪些？</h3> <p>实验小白鼠通过培养或者去逮一下，那么我们的实验用品函数如何培养出来？
目前来讲有以下几种方案：</p> <ul><li>函数声明</li> <li>函数表达式</li> <li>匿名函数</li> <li>箭头函数</li> <li>函数生成器</li></ul> <p>这里的点在于ES6中新增的箭头函数和ES7新增的函数生成器。</p> <h3 id="_2-函数有什么方法？"><a href="#_2-函数有什么方法？" class="header-anchor">#</a> 2.函数有什么方法？</h3> <p>函数是对象，它有 name 和 length 方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> d</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span>
<span class="token comment">// [&quot;a&quot;, 2]</span>
</code></pre></div><p>name 代表函数名，length 代表函数形参的数量。</p> <h3 id="_3-函数运行"><a href="#_3-函数运行" class="header-anchor">#</a> 3.函数运行</h3> <ul><li>加()</li> <li>call apply</li></ul> <p>站在编写代码的角度，函数的使用分两步，定义和运行，下面站在浏览器或者说编译器的角度来看一看。</p> <h3 id="_4-js运行三步曲"><a href="#_4-js运行三步曲" class="header-anchor">#</a> 4.js运行三步曲</h3> <ul><li>词法分析</li> <li>预编译</li> <li>解释执行</li></ul> <p>词法分析，通篇扫描，看看有没有语法错误。</p> <p>进入紧张刺激的预编译环节。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>甭管是在函数声明前调用还是在函数声明后调用，都能得到结果，这是为什么？</p> <p>换一种函数定义方式，为什么会报错误？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// a()</span>
<span class="token comment">// ^</span>

<span class="token comment">// TypeError: a is not a function</span>
</code></pre></div><p>未定义前 a 是个什么玩意？</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// undefined</span>
<span class="token comment">// hi</span>
</code></pre></div><p>上面这些状况是在预编译时引发的，那么在预编译时，函数受到了怎样的待遇？这是怎样的一套规则？</p> <h3 id="_5-预编译的过程-全文背诵"><a href="#_5-预编译的过程-全文背诵" class="header-anchor">#</a> 5.预编译的过程(全文背诵)</h3> <p>预编译发生在函数执行的前一刻。</p> <p>imply global：全局对象所有：全局变量，未经声明就赋值的变量。</p> <p>来个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>预编译的过程：</p> <ol><li>创建AO对象，Activation Object 执行期上下文。</li> <li>找形参和变量声明，将变量和形参名作为AO属性名，值为undefined。</li> <li>将实参和形参相统一。</li> <li>在函数体里找函数声明，值赋予函数体。</li></ol> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-138f30cf07ece7da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <div class="language-md extra-class"><pre class="language-md"><code>// 按照上面步骤走两步
1.
AO {

}
2.
AO {
  a:undefined,
  b:undefined
}
3. 
AO {
  a:1,
  b:undefined
}
4.
AO {
  a:function a() {},
  b:undefined,
  d:function d() {}
}
</code></pre></div><p>解释执行时用到的AO：</p> <div class="language-md extra-class"><pre class="language-md"><code>AO {
  a:function a() {},
  b:undefined,
  d:function d() {}
}
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// function</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 123</span>
  <span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 123</span>
  <span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// function</span>
  <span class="token keyword">function</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>题目：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>
<span class="token comment">// undefined</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1997</span>
  <span class="token keyword">var</span> <span class="token function-variable function">a</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2020</span>
</code></pre></div><h2 id="第七章-番外"><a href="#第七章-番外" class="header-anchor">#</a> 第七章 番外</h2> <blockquote><p>这是第七章函数表达式，这一章涉及函数预编译，闭包，作用域链内容。函数涉及内容繁多。今天来看作用域链。</p></blockquote> <p>在 <a href="https://www.jianshu.com/p/1adeff1f8ca9" target="_blank" rel="noopener noreferrer">06-2 | 读JavaScript 高程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中讲了原型链。</p> <p>今天来看一看作用域链。</p> <p>那么什么是作用域？</p> <p>函数是对象，那么原型链上的东西可以用到函数身上，同时对于函数还有另外一种链叫做作用域链。</p> <p>作用域是函数的隐式属性 [[scope]]，这个属性中存放了执行期上下文。</p> <p>执行期上下文：当函数执行时，会创建一个称为执行期上下文的内部对象，一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文。当函数执行完毕，它所产生的执行期上下文会被销毁。</p> <p>[[scope]]：每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些是不可以的，这些仅仅供javascript引擎存取，[[scope]] 就是其中一个。[[scope]] 指通常的作用域，其中存储了执行器上下文的集合。</p> <p>作用域链：[[scope]] 中存储的执行期上下文对象的集合，这个集合就是链式链接，我们把这种链式链接称为作用域链。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-05e2fb4c381b8b50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-af0f001c052cbd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三个概念的关系"></p> <p>原型链的链接处是原型和另一个实例，那么作用域链的链接处是什么？</p> <p>重点在于上下文对象的集合是如何产生的。</p> <p>来个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">234</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span>
  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> glob <span class="token operator">=</span> <span class="token number">100</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>有了 <a href="https://www.jianshu.com/p/094492e6d86b" target="_blank" rel="noopener noreferrer">07 | 读JavaScript 高程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 预编译的知识，来看上面的代码。</p> <p>产生的GO如下：</p> <div class="language-md extra-class"><pre class="language-md"><code>GO: {
  this: window,
  window: Object,
  document: Object,
  a: function,
  glob: 100
}
</code></pre></div><p>前面说到作用域中存储作用域链。
<img src="https://upload-images.jianshu.io/upload_images/3750332-3d99da209acb7c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>a函数执行产生AO，AO挂到哪里？挂到作用域链的最顶端。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-2bbccd9ef5fb7db7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>当在a函数中访问变量时就是按照作用域链查找。</p> <p>a函数的执行触发了b函数的定义。
<img src="https://upload-images.jianshu.io/upload_images/3750332-8804a47470983e96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>b函数执行会创建自己的AO。
<img src="https://upload-images.jianshu.io/upload_images/3750332-82549d7a04605d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>这里有一个点，就是b函数定义时用到原型链和a函数用到的原型链是不是同一个，b用的是从a借来的还是自己copy一份？</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-e47fe647b254e666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>两者是共用的AO。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-788cf6457989e49d.gif?imageMogr2/auto-orient/strip" alt="总览"></p> <p>这也就是函数里面可以访问外部变量，而在函数外无法访问函数内部变量的原因。</p> <h2 id="第八章"><a href="#第八章" class="header-anchor">#</a> 第八章</h2> <blockquote><p>这一篇呢是第8章，主要涉及 BOM 的相关知识。</p></blockquote> <p>先来看BOM，即和浏览器相关地一些东西。</p> <p>知识点：
1.BOM 中常用的 API 对象有哪些？这些对象都是用来干什么的?
2.窗口的尺寸问题？
3.history 对象？vue router</p> <p>## 1.BOM 中常用的 API 对象有哪些？这些对象都是用来干什么的?
主要有这么些个对象：window location navigator screen history</p> <p>先来看 window 对象，作为对象应该具有属性和方法，然而现实是，为了安全很多方法被浏览器禁用了，现在主要获取一些信息，即获取属性。</p> <p>window 中有哪些我可能会用到的属性呢？</p> <p>1.1 窗口的位置
想不想移动浏览器的窗口，出于安全考虑书中的 window.moveTo() 等已经被现代浏览器禁用。</p> <p>那改变大小总行把，讲真，这部分真乱</p> <p>1.2 窗口的大小</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>window<span class="token punctuation">.</span>innerWidth<span class="token punctuation">,</span> window<span class="token punctuation">.</span>innerHeight<span class="token punctuation">,</span> window<span class="token punctuation">.</span>outerWidth<span class="token punctuation">,</span> window<span class="token punctuation">.</span>outerHeight<span class="token punctuation">]</span>
</code></pre></div><p>，你以为就完了？</p> <p>在书中有句话是这样说的。</p> <blockquote><p>在 Chrome 中，outerWidth、outerHeight 与
innerWidth、innerHeight 返回相同的值，即视口（viewport）大小而非浏览器窗口大小。</p></blockquote> <p>但你试试就会发现，这四个值没有一样的。
<img src="https://upload-images.jianshu.io/upload_images/3750332-9908c53945ebf7df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时代的车轮"></p> <p>时代的车轮滚滚向前。</p> <p>这么乱我不获取不行吗，还真不行，很多功能可能需要知道浏览器的宽度和高度，比如上拉加载更多的功能，不知道总高度，如何确定用户是否滑倒了底部？在做响应式布局时也需要这部分的信息。</p> <p>书中还提到两个属性</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token punctuation">,</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientHeight
</code></pre></div><p>和上面的放在一起看一下：
<img src="https://upload-images.jianshu.io/upload_images/3750332-cd6b14bef3c53a54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="尺寸"></p> <p>这6个尺寸都代表什么？这些 API 用起来真难受，这里有篇 2009 年关于各种尺寸的文章。 <a href="https://www.cnblogs.com/top5/archive/2009/05/07/1452135.html" target="_blank" rel="noopener noreferrer">JS获取浏览器窗口大小 获取屏幕，浏览器，网页高度宽度<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这个东西用到时再查。</p> <p>如果考虑到移动端可能情况更加的复杂。</p> <p>1.3 打开窗口
好嘞，到目前为止，书中提到的方法均被浏览器禁止了，下面来试试打开窗口。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-25bf5571a3b88887.gif?imageMogr2/auto-orient/strip" alt="window.open"></p> <p>这个东西有什么应用场景呢？在用户登录时有的网站会 open 一个新窗口，在用户输入密钥后网站会将该输入用户信息的窗口直接关闭。无需用户的确认。</p> <p>1.4 对话框
可以使用alert confirm() prompt() 但这些默认的对话框有点丑，用的场景不是很多。大家对美都是由追求的。</p> <hr> <p>下面来看第二个对象 location，该对象存储当前窗口中加载文档的信息。
<img src="https://upload-images.jianshu.io/upload_images/3750332-79e8d8367451caeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="location"></p> <p>这里由和window.open()类似功能的代码。</p> <div class="language-js extra-class"><pre class="language-js"><code>location<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token string">'https://cemcoe.com'</span><span class="token punctuation">)</span>
location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'https://cemcoe.com'</span>
</code></pre></div><p>有些网站喜欢使用这些方法搞劫持。</p> <hr> <p>下面是 navigator 和 screen 对象，略。</p> <hr> <p>下面是 history 对象，这个对象可有点东西。在使用 Vue Router 中时，你一定会遇到它。在<a href="https://www.jianshu.com/p/eee8fd817c28" target="_blank" rel="noopener noreferrer">Vue Router mode history github 404 问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
这里已经提到过 history 了，这里不再重复。</p> <p>小结：一个对象拥有属性和方法，但在BOM中的对象，因为早期的滥用，浏览器为了安全，禁止了一些方法，现在多是用来收集信息为其他编码活动做准备。</p> <p>第9章是客户端检测，浏览器的兼容问题。略。</p> <hr> <h2 id="第十到十二章"><a href="#第十到十二章" class="header-anchor">#</a> 第十到十二章</h2> <blockquote><p>这一篇呢是第10章到第12章的汇总，DOM 的相关知识，这些东西让 JavaScript 有了操作网页的能力，但像Vue等框架的出现，让开发工作不再直接地操作 DOM，这部分地知识相对会弱化一些，不过一些 API 还是要熟悉一下地。这就是将这几章汇总的原因。</p></blockquote> <ol><li>什么是DOM?</li> <li>DOM 是用来干什么的？</li> <li>如何选取DOM元素？</li> <li>如何访问节点的属性？</li></ol> <h3 id="_1-什么是dom"><a href="#_1-什么是dom" class="header-anchor">#</a> 1. 什么是DOM?</h3> <p>DOM 的全称是 Document Object Model，中文名叫文档对象模型。
<img src="https://upload-images.jianshu.io/upload_images/3750332-0b9f9669f00c6275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="来自维基百科"></p> <p>和原型链作用域链有那么些相似。</p> <p>这种类型或者说是关系是很常见的，比如历史上的中央集权制度。
<img src="https://upload-images.jianshu.io/upload_images/3750332-dbdfce198f6effb8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中央集权制度"></p> <p>以及现在的公司架构也是类型的结构。
<img src="https://upload-images.jianshu.io/upload_images/3750332-82c03b56d300c481.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公司架构"></p> <p>这种关系在数据结构和算法中有个术语叫做树结构，抽象之后长下面的样子。
<img src="https://upload-images.jianshu.io/upload_images/3750332-256142f54eebcd8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树结构">
图片来源： <a href="https://www.cnblogs.com/QG-whz/p/5168620.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/QG-whz/p/5168620.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="_2-dom-是用来干什么的？"><a href="#_2-dom-是用来干什么的？" class="header-anchor">#</a> 2. DOM 是用来干什么的？</h3> <p>讲了这么多，那么 DOM 有何用? 有了 MVVM 框架，现在直接操作 DOM 的地方确实是少了，取而代之的是通过控制数据来改变页面的视图层。所以这里也不多介绍。</p> <h3 id="_3-如何选取dom元素？"><a href="#_3-如何选取dom元素？" class="header-anchor">#</a> 3.如何选取DOM元素？</h3> <p>选择使用</p> <ul><li>querySelector()</li> <li>querySelectorAll()</li></ul> <p>书中还提到一个方法叫做 <code>matchesSelector()</code>，但搜索一下可以发现，这个东西被改成了 <code>matches()</code>。所以看这本书时还是要小心一点的，有些东西已经随着时间发生了改变。没什么能躲过时间的摧残。</p> <p>综上，选取元素可以使用 querySelector() querySelectorAll() matches()，具体用法自行探索。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-5a5b20087d3f618d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="matches"></p> <h2 id="h5"><a href="#h5" class="header-anchor">#</a> H5</h2> <p>元素选取相关：</p> <ul><li>getElementsByClassName()</li> <li>getElementById()</li></ul> <p>对类的增删改查</p> <ul><li>add</li> <li>contains</li> <li>remove</li> <li>toggle</li></ul> <hr> <h3 id="_4-如何访问节点的属性？"><a href="#_4-如何访问节点的属性？" class="header-anchor">#</a> 4. 如何访问节点的属性？</h3> <p>对于连字符的属性名转换成驼峰命名。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 访问</span>
<span class="token keyword">const</span> color <span class="token operator">=</span> demo<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor

<span class="token comment">// 修改</span>
demo<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">'#f40'</span>
</code></pre></div><p>当然了，一般很少直接使用 js 修改样式值，这样的需求一般是通过切换 class 名实现的。因为直接使用 js 修改样式，js 和 css 代码会混杂在一起，不符合结构行为样式相分离的规范。</p> <p>接下来是元素尺寸相关的问题。和 BOM 尺寸放在一起有空看。</p> <p>好嘞，就这些。</p> <h2 id="第十三章"><a href="#第十三章" class="header-anchor">#</a> 第十三章</h2> <blockquote><p>这一篇呢是第13章，内容是和事件相关。</p></blockquote> <p>事件可以看成是条件判断的一种条件，逻辑是某个元素发生了某个事情，我要做出相应的反应。</p> <p>有个叫做ifttt的服务将这种逻辑发挥到了极致。</p> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-d430698cbfaa9bf6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ifttt"></p> <p>核心是如何监控事件，进而引发有哪些事件可以监控的问题？</p> <p>知识点：
1.我点的是谁？
2.如何监测事件？
3.有哪些事件可以监听？
4.要监听的事件过多，处理不过来，怎么办？
5.我可不可以自定义事件嘞？</p> <h3 id="_1-我点的是谁？"><a href="#_1-我点的是谁？" class="header-anchor">#</a> 1.我点的是谁？</h3> <p><img src="https://upload-images.jianshu.io/upload_images/3750332-3f05842c341fd7f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>当1被点击时，2和3被点击了吗？这里的规定是是的，甚至整个页面都被点击了，这其实有点地图炮的意味，某人怎样可以上升到某省怎样，再上升到全人类怎样。</p> <p>既然都被点击了，那我要监控某个元素要如何搞，虽然都被点击了，但总要有个先后顺序的。</p> <p>事件冒泡event bubbling，事件从最具体的元素接收，向上传播，即1-&gt;2-&gt;3</p> <p>事件捕获event capturing，不太具体的节点最早接收事件，最具体的节点最后接收事件，目的是再事件到达预定目标前捕获事件，让事件去遛一圈，我好准备，即3-&gt;2&gt;1。</p> <p>DOM2级事件规定的流程是：事件捕获，处于目标阶段，和事件冒泡。即3-&gt;2-&gt;1-&gt;2-&gt;3。</p> <p>整的还挺复杂。</p> <h3 id="_2-如何监测事件？"><a href="#_2-如何监测事件？" class="header-anchor">#</a> 2.如何监测事件？</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// DOM0 级事件处理程序</span>
btn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">null</span>

<span class="token comment">// DOM2 级事件处理程序</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token comment">// false 指事件处于冒泡阶段时触发。</span>
</code></pre></div><h3 id="_3-事件对象长啥样？"><a href="#_3-事件对象长啥样？" class="header-anchor">#</a> 3.事件对象长啥样？</h3> <p>当触发DOM事件时，会产生一个事件对象event，该对象包含了与事件相关的信息。</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="https://upload-images.jianshu.io/upload_images/3750332-13e53f3e45225f16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="event"></p> <p>3.有哪些事件可以监听？
根据手机壳改变主题。</p> <p>用的最多的要数click事件，其实可以监听的事件还有很多种。这里列出使用过的。</p> <p>click 点击事件
scroll 事件在移动端经常使用
focus 获得焦点
blur 失去焦点
鼠标事件，最近喜欢上了触摸板，就不测试了。</p> <p>移动端事件，300ms延迟。
触摸事件：
touchstart
touchmove
touchend
touchcancel</p> <h3 id="_4-要监听的事件过多，处理不过来，怎么办？"><a href="#_4-要监听的事件过多，处理不过来，怎么办？" class="header-anchor">#</a> 4.要监听的事件过多，处理不过来，怎么办？</h3> <p>监听的事件过多，会消耗计算资源，如何节省计算资源呢？事件委托并移除事件处理程序。</p> <p>很简单，有事秘书干。这个术语叫做事件委托，指定一个事件处理程序管理某一类型的所有事件。</p> <p>思路是在顶层注册事件，在回调中判断点击的实际对象并做相应的处理。click非常适合采用事件委托技术。</p> <h3 id="_5-我可不可以自定义事件嘞？"><a href="#_5-我可不可以自定义事件嘞？" class="header-anchor">#</a> 5.我可不可以自定义事件嘞？</h3> <p>说白了，事件对象就是一系列属性的集合，前面看到的各种事件不过时一些属性上的差异，如果我们创建一个对象并比照event对象添加一些属性，那么就可以自定义事件了，术语叫做模拟事件。</p> <p>模拟事件的流程：创建 event 对象，相关信息初始化，触发事件。</p> <h2 id="第二十章json"><a href="#第二十章json" class="header-anchor">#</a> 第二十章JSON</h2> <blockquote><p>第14至19章有特定的应用场景，这里先略过。先看第20章，跨度有点大，该章内容主要是对JSON这种数据格式的讲解。</p></blockquote> <h3 id="_1-json的格式规范有哪些？"><a href="#_1-json的格式规范有哪些？" class="header-anchor">#</a> 1.JSON的格式规范有哪些？</h3> <p>在 <a href="https://www.jianshu.com/p/9f4af893e9e7" target="_blank" rel="noopener noreferrer">Mock | 数据过家家<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中其实就用到了JSON这种数据格式。目前，前后端数据传输是使用这种数据格式进行的。</p> <p>当你打开接口时看到的可能是这样的：
<img src="https://upload-images.jianshu.io/upload_images/3750332-01ca4c4e516cda48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="很整洁"></p> <p>很乱有没有，这时需要一个叫做 JSON Formatter 的插件来帮我们美化一下。
<img src="https://upload-images.jianshu.io/upload_images/3750332-ff2d9cb8dd99e9c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这样才对"></p> <h3 id="解析和序列化"><a href="#解析和序列化" class="header-anchor">#</a> 解析和序列化</h3> <p><code>JSON.parse()</code> 把 JSON 字符串解析为原生 JavaScript 值
<code>JSON.stringify()</code> 将JavaScript 对象序列化为 JSON 字符串
<img src="https://upload-images.jianshu.io/upload_images/3750332-883d14fd5414c906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p> <p>JSON.stringify()可以搞三个参数</p> <ul><li>要序列化的 JavaScript 对象外</li> <li>过滤器，可以是一个数组，也可以是一个函数</li> <li>选项，表示是否在 JSON 字符串中保留缩进</li></ul> <p>JSON 这种数据格式连接了前端和后端，就像时人体中的养料，下一章是人体中的运输工具 ajax。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/25/2020, 9:10:02 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/fe/assets/js/app.d7dafe9a.js" defer></script><script src="/fe/assets/js/2.11505e39.js" defer></script><script src="/fe/assets/js/8.ff512c9c.js" defer></script>
  </body>
</html>
